"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObservabilityLogger = void 0;
const types_1 = require("./types");
const config_1 = require("./config");
const metrics_1 = require("./metrics");
const circuit_breaker_1 = require("./circuit-breaker");
const connection_1 = require("./connection");
const publisher_1 = require("./publisher");
class ObservabilityLogger {
    constructor(config, publisher) {
        this.config = (0, config_1.createDefaultConfig)(config);
        this.metrics = (0, metrics_1.createInitialMetrics)();
        this.circuitBreaker = (0, circuit_breaker_1.createCircuitBreaker)(this.config.circuitBreakerThreshold, this.config.circuitBreakerTimeout);
        this.connection = (0, connection_1.createRabbitMQConnection)(this.config, () => this.connect());
        this.publisher =
            publisher ||
                (0, publisher_1.createPublisher)(this.config, this.connection, this.circuitBreaker);
    }
    async connect() {
        await this.connection.connect();
        this.metrics.connectionStatus = this.connection.isConnected
            ? 'connected'
            : 'disconnected';
    }
    async handlePublish(message) {
        const startTime = Date.now();
        const result = await this.publisher.publishMessage(message);
        const publishTime = Date.now() - startTime;
        this.metrics = (0, metrics_1.updateMetrics)(this.metrics, publishTime, result.success);
        return result;
    }
    async trace(message, context) {
        return this.handlePublish({
            level: types_1.LogLevel.TRACE,
            message,
            context: context || undefined,
        });
    }
    async debug(message, context) {
        return this.handlePublish({
            level: types_1.LogLevel.DEBUG,
            message,
            context: context || undefined,
        });
    }
    async info(message, context) {
        return this.handlePublish({
            level: types_1.LogLevel.INFO,
            message,
            context: context || undefined,
        });
    }
    async warn(message, context) {
        return this.handlePublish({
            level: types_1.LogLevel.WARN,
            message,
            context: context || undefined,
        });
    }
    async error(message, error, context) {
        return this.handlePublish({
            level: types_1.LogLevel.ERROR,
            message,
            context: context || undefined,
            error: error
                ? {
                    name: error.name,
                    message: error.message,
                    stack: error.stack || undefined,
                }
                : undefined,
        });
    }
    async fatal(message, error, context) {
        return this.handlePublish({
            level: types_1.LogLevel.FATAL,
            message,
            context: context || undefined,
            error: error
                ? {
                    name: error.name,
                    message: error.message,
                    stack: error.stack || undefined,
                }
                : undefined,
        });
    }
    async businessEvent(event) {
        return this.handlePublish({
            level: types_1.LogLevel.INFO,
            message: `Business Event: ${event.eventType}`,
            metadata: event,
        });
    }
    async securityEvent(event) {
        const level = event.severity === 'critical' || event.severity === 'high'
            ? types_1.LogLevel.ERROR
            : types_1.LogLevel.WARN;
        return this.handlePublish({
            level,
            message: `Security Event: ${event.eventType}`,
            metadata: event,
        });
    }
    async logBatch(messages) {
        const results = await Promise.all(messages.map((message) => this.handlePublish(message)));
        const successful = results.filter((r) => r.success);
        const failed = results.filter((r) => !r.success);
        return {
            success: failed.length === 0,
            batchId: '', // Batch ID can be generated if needed
            processed: successful.length,
            failed: failed.length,
            timestamp: new Date().toISOString(),
            errors: failed.map((result, index) => ({
                index,
                error: result.error?.message || 'Unknown error',
            })),
        };
    }
    getMetrics() {
        return (0, metrics_1.getFullMetrics)(this.metrics, this.circuitBreaker.state, this.circuitBreaker.failures, this.circuitBreaker.lastFailure, this.config.circuitBreakerTimeout);
    }
    async close() {
        if (this.batchTimer) {
            clearTimeout(this.batchTimer);
        }
        await this.connection.close();
        this.metrics.connectionStatus = 'disconnected';
    }
}
exports.ObservabilityLogger = ObservabilityLogger;
//# sourceMappingURL=logger.js.map